---
title: "Reticulate test"
output: html_notebook
---

```{r}
library(reticulate)
copytree_path <- "/Users/zemp/phd/scilife/coPyTree"
```

Read numpy file

```{r}
read_diagnostics <- function(dir_path, convert = TRUE) {
  np <- import('numpy', convert = convert)
  # read all diagnostics files
  out <- list(copy_num = np$load(file.path(dir_path, 'copy.npy')),
              cell_assignment = np$load(file.path(dir_path, 'cell_assignment.npy')),
              pi = np$load(file.path(dir_path, 'pi.npy')),
              eps_a = np$load(file.path(dir_path, 'eps_a.npy')),
              eps_b = np$load(file.path(dir_path, 'eps_b.npy')),
              nu = np$load(file.path(dir_path, 'nu.npy')),
              lambda = np$load(file.path(dir_path, 'lambda.npy')),
              alpha = np$load(file.path(dir_path, 'alpha.npy')),
              beta = np$load(file.path(dir_path, 'beta.npy')),
              elbo = np$load(file.path(dir_path, 'elbo.npy'))
              )
  return(out)
}

diag_list <- read_diagnostics(file.path(copytree_path, "output/diagnostics"))
```

Import ggplot
```{r}
library(ggplot2)
library(ggpubr)
library(tibble)

n_iter <- dim(diag_list$copy_num)[1]
K <- dim(diag_list$copy_num)[2]
M <- dim(diag_list$copy_num)[3]
A <- dim(diag_list$copy_num)[4]
N <- dim(diag_list$cell_assignment)[2]
```

```{r}
with(diag_list, {
  elbo_df <- tibble(x = 1:length(elbo), y = elbo)
  ggplot(elbo_df) +
    geom_line(aes(x, y)) +
    labs(title = 'ELBO', x = 'it', y = 'elbo')
})
```

## Cell assignment

```{r}
# diag_list$cell_assignment shape (n_iter, N, K)
library(reshape2)
library(dplyr)
melt(diag_list$cell_assignment, value.name = 'prob', varnames = c('iter', 'cell', 'clone')) %>%
  filter(cell %in% sample(1:N, 20)) %>%
  mutate(clone = factor(clone - 1L, levels = 0:(K-1))) %>%
  ggplot() +
    geom_line(aes(x = iter, y = prob, color = clone)) +
    facet_wrap(~ cell)
```


## Copy number plot
TODO: improve by plotting probability mass on each state with color scale mapping
```{r}
# select node 1 (with take, axis=1, el=1) and argmax
# np <- import('numpy')
# copy_max_node1 <- np$argmax(np$take(diag_list$copy_num, 1L, 1L), axis=-1L)
# or in base R

with(diag_list, {
  it_step <- 50
  li <- list()
  pidx <- 1L
  for (k in 1:K) {
    for (it in seq(1, n_iter, it_step)) {
      copy_it_k <- apply(copy_num[it, k,,], 1, which.max) - 1L
      copy_tibble <- tibble(cn = copy_it_k, site = 1:M)
      # make plot_cn function
      p <- ggplot(copy_tibble) +
        geom_line(aes(x=site, y=cn)) +
        labs(title=paste('CN clone', k, 'it', it)) +
        scale_y_continuous(breaks = 1:A - 1L)
        
      li[[pidx]] <- p
      
      pidx <- pidx + 1
    }
  }
  ggarrange(plotlist = li, nrow = K, ncol = ceiling(n_iter / it_step))
})
```
TODO: implement quick comparison with true and inferred tree, clustering, copy
numbers etc

# Ground truth comparison

```{r}
read_gt <- function(dir_path, convert = TRUE) {
  np <- import('numpy', convert = convert)
  # read all diagnostics files
  gt_out <- list(copy_num = np$load(file.path(dir_path, 'copy.npy')),
              cell_assignment = as.integer(np$load(file.path(dir_path, 'cell_assignment.npy'))),
              pi = np$load(file.path(dir_path, 'pi.npy')),
              eps = np$load(file.path(dir_path, 'eps.npy')),
              mu = np$load(file.path(dir_path, 'mu.npy')),
              tau = np$load(file.path(dir_path, 'tau.npy'))
              )
  return(gt_out)
}

gt_list <- read_gt(file.path(copytree_path, 'datasets/gt_simul_K4_A5_N100_M500'))

```

## Clustering evaluation

```{r}
library(aricode)

ari <- c()
for (it in 1:n_iter) {
  c2 <- apply(diag_list$cell_assignment[it,,], 1, which.max) - 1L
  ari <- append(ari, ARI(gt_list$cell_assignment, c2))
}

ari_df <- tibble(ari = ari, it = 1:n_iter)

ggplot(ari_df) +
  geom_line(aes(it, ari))

```
Clustering matchings table
```{r}
matchings <- matrix(rep(0, K^2), nrow = K)
final_ca <- apply(diag_list$cell_assignment[101,,], 1, which.max) - 1L
for (n in 1:N) {
  a <- gt_list$cell_assignment[n] + 1
  b <- final_ca[n] + 1
  matchings[a, b] <- matchings[a, b] + 1
}
matchings
```

print vi clones map associated with ground truth
```{r}
gt_vi_map <- matchings %>%
  melt(value.name = 'count', varnames = c('gt', 'vi')) %>%
  mutate(gt = gt - 1, vi = vi - 1) %>%  # switch to 0-based clone names
  group_by(gt) %>%                      # for each clone 
  mutate(prop = count / sum(count)) %>% # find proportions of vi matches
  filter(prop == max(prop)) %>%         # get the max proportion
  select(gt, vi, prop)

gt_vi_map
```
```{r}
# usage: to get the correspondent clone in vi names
k <- 1
gt_vi_map %>%
  filter(gt == k) %>%
  pull(vi)
```
## Tree evaluation

```{r}
library(tidyr)
# get gt tree edges
edges <- which(gt_list$eps > 0, arr.ind = TRUE)

li <- list()
idx <- 1L
for (e in 1:(K-1)) {
  u <- edges[e, 1]
  v <- edges[e, 2]
  eps_df <- tibble(
    it = 1:n_iter,
    a = diag_list$eps_a[, u, v], 
    b = diag_list$eps_b[, u, v],
    mm = a / (a + b),
    stdev = sqrt(a * b) / ((a + b) * sqrt(a + b + 1)),
    gt = rep(gt_list$eps[u, v], n_iter))
  
  eps_ab_plot <- eps_df %>%
    select(a, b, it) %>%
    gather(key = 'param', value = 'value', a, b) %>%
    ggplot() +
    geom_line(aes(x = it, y = value)) +
    facet_wrap(~ param, nrow = 2)
  
  eps_mean_plot <- eps_df %>%
    select(it, mm, stdev, gt) %>%
    ggplot(aes(x = it)) +
      geom_line(aes(y = mm)) +
      geom_line(aes(y = gt), color = 'red') +
      geom_ribbon(aes(ymin = mm-stdev, ymax = mm+stdev), alpha = 0.3) +
      labs(title = paste0('edge (', u, ',', v, ')'))
  li[[idx]] <- eps_ab_plot
  li[[idx + K-1]] <- eps_mean_plot
  idx <- idx + 1
}

ggarrange(plotlist = li, nrow = K-1)
```

## Copy eval

```{r}
li <- list()
for (k in 1:K) {
  copy_it_k <- apply(diag_list$copy_num[n_iter, k,,], 1, which.max) - 1L
  copy_tibble <- tibble(cn = c(copy_it_k, gt_list$copy_num[k,]), site = c(1:M, 1:M), kind = c(rep('vi', M), rep('gt', M)))
  p <- ggplot(copy_tibble) +
    geom_line(aes(x=site, y=cn, color=kind)) +
    geom_line(aes(x=site, y=cn, color=kind, linetype=kind)) +
    labs(title=paste('CN clone', k-1L)) +
    scale_y_continuous(breaks = 1:A - 1L)
  li[[k]] <- p
}
ggarrange(plotlist = li, nrow = K, ncol = 1L)
```